# Строки

## Кавычки

Строку можно создать с помощью одинарных, двойных либо обратных кавычек.

Одинарные и двойные кавычки работают одинаково, а если использовать обратные кавычки, то в такую строку мы сможем вставлять произвольные выражения, обернув их в `${...}`

Также их преимущество в том, что они могут занимать более одной строки.

Обратные кавычки также позволяют задавать "шаблонную функцию" перед первой обратной кавычкой. Используемый синтаксис:  **func`string`**. Автоматически вызываемая функция получает строку и встроенные в нее выражения и может их обрабатывать. Если перед строкой есть выражение, то шаблонная строка называется "теговым шаблоном".

## Спецсимволы

`\n` - перевод строки
`\r` - в текстовых файлах Windows для перевода строки используется кобинация символов `\r\n`, а на других ОС это просто `\n`.
`\', \"` -  кавычки
`\\` - обратный слел
`\t` - табуляция
`\b, \f, \v` - Backspace, Form Feed, Vertical Tab - оставлены для обратной совместимости, сейчас не используется
`\xXX` - символ с шестнадцатеричным юникодом `XX`, например, `\x7A` - то же самое, что `z`
`\uXXXX` - символ в кодировке UTF-16

Все спецсимволы начинаются с обратного слеша - так называемого "символа экранирования".

Обратный слеш служит лишь для корректного прочтения строки интерпретатором, но он не записывается в строку после ее прочтения. Когда строка сохраняется в оперативную память, в нее не добавляется символ обратного слеша.

## Длина строки

Свойство `length` содержит длину строки.

## Доступ к символам

Получить символ, можно по его индексу, также можно использоваться `charAt`. Первый символ занимает нулевую позицию.

Квадратные скобки - современный способ получить символ.

Разница скобок и `charAt`, скобки вернут `undefined`, `charAt` - пустую строку. 

## Строки неизменяемы

Содержимое строки нельзя изменить. Нельзя изменить символ в строке.

## Изменение регистра

`toLowerCase()`, `toUpperCase()` меняют регистр символов.

## Поиск подстроки

`str.indexOf(substr, pos)`. Метод ищет подстроку в строке, начиная с позиции, и возвращает позицию, на которой располагается совпадение, либо `-1` при отсутствии совпадений.

`str.lastIndexOf(substr, position)`. Тоже самое, только с конца.

`str.includes(substr, pos)`. Возвращает `true`/`false`, если есть подстрока `substr`. Второй аргумент позволяет начать поиск с определенной позиции.

`str.startsWith` и `str.endsWith`. Проверяют начинается ли и заканчивается ли строка определенной строкой.

## Получение подстроки

`str.slice(start [, end])`. Возвращает часть строки от `start` до `end`. Можно задавать отрицательные значения.

`str.substring(start [, end])`. Возвращает часть строки. Но разница между `slice`, но можно задвать `start` больше `end`. Если `start` больше `end`, то метод `substring` сработает так, как если бы аргументы были поменяны местами. Не поддерживает отрицательные значения.

`str.substr(start [, length])`. Возвращает часть строки от `start` длины `length`. Позволяет указывать длину вместо конечно позиции.

## Сравнение строк

Строки сравниваются посимвольно в алфавитно порядке.
1. Строчные буквы больше заглавных.
2. Буквы, имеющие диакритические знаки, идут "не по порядку"
```
 alert( 'Österreich' > 'Zealand' );
```

Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код. Есть специальные методы, позволяющие получить символ по его коду и наоборот.

`str.codePointAt(pos)`. Возвращает код для символа, находящегося на позиции `pos`.
`String.fromCodePoint(code)`. Создает символ по его коду.

Также можно добавлять юникодные символы по их кодам, используя `\u` с шестнадцатеричным кодом символа.

Символы сравниваются по их кодам. Больший код — больший символ. Код a (97) больше кода Z (90).

Все строчные буквы идут после заглавных, так как их коды больше.
Некоторые буквы, такие как Ö, вообще находятся вне основного алфавита. У этой буквы код больше, чем у любой буквы от a до z.