# Массивы

## Объявление

Существует два варианта объявления массива:

```
  let arr = new Array();
  let arr = [];
```

Чаще всего используется второй вариант инициализации, в скобках можно указать начальные значения

```
  let fruits = ["Яблоко", "Апельсин", "Слива"];
```

Элементы массива нумеруются, начиная с нуля.

Чтобы получить элемент, нужно указать его номер в квадратных скобках.

```
  let fruits = ["Яблоко", "Апельсин", "Слива"];

  alert( fruits[0] ); // Яблоко
  alert( fruits[1] ); // Апельсин
  alert( fruits[2] ); // Слива
```

Можно заменить элемент 

```
  fruits[2] = 'Груша'
```

или добавить новый элемент

```
  fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
```

Для получения длины массива есть свойство `length`

В массиве могут храниться элементы любого типа.

## Методы pop/push, shift/unshift

Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:

- `push` добавляет элемент в конец.
- `shift` удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.

Массивы поддерживают обе операции.

Существует и другой вариант применения для массивов – структура данных, называемая стек.

Она поддерживает два вида операций:

- `push` добавляет элемент в конец.
- `pop` удаляет последний элемент.

Таким образом, новые элементы всегда добавляются или удаляются из «конца».

Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху.

Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива

### Методы, работающие с концом массива:

- `pop` - удаляет последний элемент в массиве
- `push` - добавляет элемент в конец массива

### Методы, работающие с началом массива:

- `shift` - удаляет первый элемент в массиве
- `unshift` - Добавляет элемент в начало массива

## Внутреннее устройство массива

Массив - подвид объектов. Где доступ к элементам осуществляется через квадратные скобки, где в качестве ключей используются числовые индексы.

Массивы расширяют объекты, так как предоставляют специальные методы для работы с упорядоченными коллекциями данных.

Движок JS старается старается работать с массивом в непрерывной области памяти, один за другим. Существуют и другие способы оптимизации, благодаря которым массивы работают очень быстро. Но они утратят эффект, если начать работать с массивом, как с объектом. 

```
  let fruits = []; // создаём массив

  fruits[99999] = 5; // создаём свойство с индексом, намного превышающим длину массива

  fruits.age = 25; // создаём свойство с произвольным именем
```

Это возможно, так как в основе массив лежит объект. 

### Варианты неправильного применения массива

1. Добавление нечислового свойства, например: `arr.test = 5`
2. Создание «дыр», например: добавление `arr[0]`, затем `arr[1000]` (между ними ничего нет).
3. Заполнение массива в обратном порядке, например: `arr[1000]`, `arr[999]`.

Массив следует считать особой структурой, позволяющей работать с упорядоченными данными.

## Эффективность

Методы `push/pop` выполняются быстро, а методы `shift/unshift` – медленно.

### Почему работать с концом массива быстрее, чем с его началом?

`fruits.shift()`. Метод удаляет первый элемент. Но этого недостаточно. Нужно заново пронумеровать остальные элементы.

Операция `shift` должна выполнить 3 действия:

- Удалить элемент с индексом `0`.
- Сдвинуть все элементы влево, заново пронумеровать их, заменив `1` на `0`, `2` на `1` и т.д.
- Обновить свойство `length`.

## Перебор элементов

Самый простой способ:

```
  let arr = ["Яблоко", "Апельсин", "Груша"];

  for (let i = 0; i < arr.length; i++) {
    alert( arr[i] );
  }
```

Но для массивов возможен и другой вариант цикла, `for..of`:

```
  let fruits = ["Яблоко", "Апельсин", "Слива"];

  // проходит по значениям
  for (let fruit of fruits) {
    alert( fruit );
  }
```

Цикл `for..of` не предоставляет доступа к номеру текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.

Технически, так как массив является объектом, можно использовать и вариант `for..in`

```
  let arr = ["Яблоко", "Апельсин", "Груша"];

  for (let key in arr) {
    alert( arr[key] ); // Яблоко, Апельсин, Груша
  }
```

Но на самом деле это плохая идея. Существуют скрытые недостатки этого способа:

1. Цикл выполняет перебор всех свойств объекта, не только цифровых.
2. Цикл оптимизирован под произвольные объекты, поэтому будет работать медленнее