# Методы массивов

## splice

**delete** удаляет значение элемента по ключу, но длина остается прежней

**splice** - универсальный метод, который позволяет добавлять, удалять и заменять элементы:
```
  arr.splice(index[, deleteCount, elem1, ..., elemN)
```
где первый параметр это позиция, второй параметр позволяет удалить `deleteCount` элементов, а `elem1, ...,elemN` вставляет на их мето новые элементы. Возвращает массив из удаленных элементов.

Если необходимо просто добавить элементы без удаления, то `deleteCount` должно быть равно 0, при этом index должен быть равен длине массив, иначе другие элементы перезапишутся

Также разрешены и отрицательный индекс, который позволяет начать с конца отсчет элементов. `index = -1` - предпоследний элемент.

## slice

```
  arr.slice(start, end)
```

Метод возвращает новый массив, в который копирует элементы, начиная с индекса `start` и до `end`(не включая `end`)

`slice` без параметров просто создает копию массива

## concat

Создает новый массив, в который копирует данные из других массивов и дополнительные значения.

```
  arr.concat(arg1, arg2...)
```

Принимает любое количество аргументов, которые могут быть как массив, так и простыми значениями.

В результате получаем новый массив.

```
  let arr = [1, 2];
  
  // создать массив из: arr и [3,4]
  alert( arr.concat([3, 4]) ); // 1,2,3,4
  
  // создать массив из: arr и [3,4] и [5,6]
  alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6
  
  // создать массив из: arr и [3,4], потом добавить значения 5 и 6
  alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

Обычно метод копирует элементы элементы из массивов. Другие объекты, даже если они выглядят как массивы добавляются как есть:

```
  let arr = [1, 2];
  
  let arrayLike = {
    0: "что-то",
    length: 1
  };
  
  alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```

Но если объект имеет специальное свойство `Symbol.isConcatSpreadable`, который обрабатывается `concat` как массив: вместо него добавляются его числовые свойства

Для корректной обработки в объекте должны быть числовые свойства и `length`

```
  let arr = [1, 2];
  
  let arrayLike = {
    0: "что-то",
    1: "ещё",
    [Symbol.isConcatSpreadable]: true,
    length: 2
  };
  
  alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
```

## Перебор: forEach

Функция позволяет перебирать каждый элемент массива. Функция принимает в себя `callback` с тремя аргументами: `item`, `index`, `array`.

Результат функции ничего не возвращает.

## Поиск в массиве

### indexOf/lastIndexOf и includes

Имеет одинаковый синтаксис и делают по сути тоже самое.

- `arr.indexOf(item, from)` ищет `item`, начиная с индекса `from`, и возвращает индекс, на котором находится найденный элемент, в ином случае возвращается -1
- `arr.lastIndexOf(item, from)` - то же самое, но ищет справа налево.
- `arr.includes(item, from)` - ищет `item`, начиная с индекса `from`, возвращает `true`, если поиск успешен

Методы используют строгое сравнение `===`. 

Если необходимо проверить наличие элемента и нет необходимости знать его точный индекс, тогда предпочтительным является `arr.includes`.

Также `includes` обрабатывает `NaN` в отличие от `indexOf/lastIndexOf`:

```
  const arr = [NaN];
  alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
  alert( arr.includes(NaN) );// true (верно)
```

### find и findIndex

`arr.find(callback)` - принимает в себя callback c тремя аргументами: `item`, `index`, `array`. Возвращает найденный элемент, либо `undefined`. Когда элемент найден, поиск прерывается.

`arr.findIndex(callback)` - тоже самое, но возвращает индекс, если ничего не найдено возвращает `-1`

### filter

Возвращает элементы элементы, которые соответствуют условию

```
  let results = arr.filter(function(item, index, array) {
    // если true - элемент добавляется к результату, и перебор продолжается
    // возвращается пустой массив в случае, если ничего не найдено
  });
```

## Преобразование массива

### arr.map(callback)

Перебирает элементы, возвращая новый массив.

### sort(fn)

Сортирует массив на месте, меняя в нём порядок элементов.

Возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется массив от которой вызвали функцию `sort`

По умолчанию элементы сортируются как строки. Преобразуются при сравнении.

```
  let arr = [ 1, 2, 15 ];
  
  // метод сортирует содержимое arr
  arr.sort();
  
  alert( arr );  // 1, 15, 2
```

Для сортировки чисел нужно написать отдельную функцию, которую передаем в качестве аргумента в `sort`

```
  function compare(a, b) {
    if (a > b) return 1; // если первое значение больше второго
    if (a == b) return 0; // если равны
    if (a < b) return -1; // если первое значение меньше второго
  }
```

Функция должна возвращать значения.

Метод реализует общий алгоритм сортировки. Она проходится по массиву, сравнивает его элементы с помощью предоставленной функции и переупорядочивает их. Все, что остается нам, это предоставить `fn`, которая делает это сравнение.

В процессе работы алгоритм может сравнивать элемент с другими по нескольку раз, но он старается сделать как можно меньше сравнений.

## reverse

Меняет порядок на обратный

## split и join

`split` -  разбивает строку на массив, в аргументе передается `delimiter`, который является разделителем. У функции есть второй необязательный параметр, который задает длину массива.

`join` -  объединяет массив в строку через `delimiter`

## reduce/reduceRight

Методы используются для вычисления, при котором возвращается единое значение.

Применяется по очереди ко всем элементам массива и переносит свой результат на следущий вызов 

Аргументы:
- `previousValue (sum)` - результат предыдущего вызова этой функции, равен `initial`, который передается во втором аргументе у функции
- `item` - элемент массива
- `index` - индекс
- `array` - сам массив

При вызове функции результат ее вызова на предыдущем элементе массива передается как первый аргумент.

```
  let arr = [1, 2, 3, 4, 5];
  
  let result = arr.reduce((sum, current) => sum + current, 0);
  
  alert(result); // 15
```

Как работает алгоритм.

1. При первом запуске `sum` равен `initial`, то есть `0`, а `current` - первый элемент массива, равный `1`.
2. При втором запуске `sum = 1`, и к нему добавляется второй элемент массива
3. При третьем запуске, к которому мы добавляем следующий элемент и т.д.

 Если массив пуст, то вызов `reduce` без начального значения выдаст ошибку.
 
`reduceRight` работает аналогично, но проходит по массиву справа налево.

## Array.isArray

```
  typeof {} // object
  typeof [] // тоже объект
```

`Array.isArray(value)` - возвращает `true/false` если `value` либо массив, либо другое не массив.

## Большинство методов поддерживают «thisArg»

Почти все методы массива, которые вызывают функции `sort`, принимают необязательный параметр `thisArg`.

`thisArg` - это `this` для `func`