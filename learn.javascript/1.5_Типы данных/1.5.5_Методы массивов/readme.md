# Методы массивов

## splice

**delete** удаляет значение элемента по ключу, но длина остается прежней

**splice** - универсальный метод, который позволяет добавлять, удалять и заменять элементы:
```
  arr.splice(index[, deleteCount, elem1, ..., elemN)
```
где первый параметр это позиция, второй параметр позволяет удалить `deleteCount` элементов, а `elem1, ...,elemN` вставляет на их мето новые элементы. Возвращает массив из удаленных элементов.

Если необходимо просто добавить элементы без удаления, то `deleteCount` должно быть равно 0, при этом index должен быть равен длине массив, иначе другие элементы перезапишутся

Также разрешены и отрицательный индекс, который позволяет начать с конца отсчет элементов. `index = -1` - предпоследний элемент.

## slice

```
  arr.slice(start, end)
```

Метод возвращает новый массив, в который копирует элементы, начиная с индекса `start` и до `end`(не включая `end`)

`slice` без параметров просто создает копию массива

## concat

Создает новый массив, в который копирует данные из других массивов и дополнительные значения.

```
  arr.concat(arg1, arg2...)
```

Принимает любое количество аргументов, которые могут быть как массив, так и простыми значениями.

В результате получаем новый массив.

```
  let arr = [1, 2];
  
  // создать массив из: arr и [3,4]
  alert( arr.concat([3, 4]) ); // 1,2,3,4
  
  // создать массив из: arr и [3,4] и [5,6]
  alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6
  
  // создать массив из: arr и [3,4], потом добавить значения 5 и 6
  alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

Обычно метод копирует элементы элементы из массивов. Другие объекты, даже если они выглядят как массивы добавляются как есть:

```
  let arr = [1, 2];
  
  let arrayLike = {
    0: "что-то",
    length: 1
  };
  
  alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```

Но если объект имеет специальное свойство `Symbol.isConcatSpreadable`, который обрабатывается `concat` как массив: вместо него добавляются его числовые свойства

Для корректной обработки в объекте должны быть числовые свойства и `length`

```
  let arr = [1, 2];
  
  let arrayLike = {
    0: "что-то",
    1: "ещё",
    [Symbol.isConcatSpreadable]: true,
    length: 2
  };
  
  alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
```

## Перебор: forEach

Функция позволяет перебирать каждый элемент массива. Функция принимает в себя `callback` с тремя аргументами: `item`, `index`, `array`.

Результат функции ничего не возвращает.

## Поиск в массиве

### indexOf/lastIndexOf и includes

Имеет одинаковый синтаксис и делают по сути тоже самое.

- `arr.indexOf(item, from)` ищет `item`, начиная с индекса `from`, и возвращает индекс, на котором находится найденный элемент, в ином случае возвращается -1
- `arr.lastIndexOf(item, from)` - то же самое, но ищет справа налево.
- `arr.includes(item, from)` - ищет `item`, начиная с индекса `from`, возвращает `true`, если поиск успешен

Методы используют строгое сравнение `===`. 

Если необходимо проверить наличие элемента и нет необходимости знать его точный индекс, тогда предпочтительным является `arr.includes`.

Также `includes` обрабатывает `NaN` в отличие от `indexOf/lastIndexOf`:

```
  const arr = [NaN];
  alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
  alert( arr.includes(NaN) );// true (верно)
```

## find и findIndex

`arr.find(callback)` - принимает в себя callback c тремя аргументами: `item`, `index`, `array`. Возвращает найденный элемент, либо `undefined`. Когда элемент найден, поиск прерывается.

`arr.findIndex(callback)` - тоже самое, но возвращает индекс, если ничего не найдено возвращает `-1`

## filter

Возвращает элементы элементы, которые соответствуют условию

```
  let results = arr.filter(function(item, index, array) {
    // если true - элемент добавляется к результату, и перебор продолжается
    // возвращается пустой массив в случае, если ничего не найдено
  });
```