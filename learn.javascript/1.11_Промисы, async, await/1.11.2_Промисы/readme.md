# Промисы

Promise - это объект, представляющий результат успешного или неудачного завершения асинхронной операции.

Промис создается через конструктор `new Promise(callback)`. В конструктор класса передается колбэк с двумя аргументами: `resolve` и `reject`. Данная функция называется исполнителем (executor). Когда промис создается, функция автоматически запускается.

Аргументы `resolve` и `reject` являются колбэками, которые предоставляем сам JavaScript. Когда промис получает результат, он должен вызвать один из этих колбэком:

- `resolve(value)` - если работа завершилась успешно, с результатом `value`
- `reject(error)` - если произошла ошибка, `error` - объект ошибки.

Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать `resolve` или `reject`.

У объекта `promise` есть внутренние свойства:

- `state` («состояние») — вначале `"pending`" («ожидание»), потом меняется на `"fulfilled"` («выполнено успешно») при вызове `resolve` или на `"rejected"` («выполнено с ошибкой») при вызове `reject`.
- `result` («результат») — вначале `undefined`, далее изменяется на `value` при вызове `resolve(value)` или на error при вызове `reject(error)`.

Так что исполнитель по итогу переводит `promise` в одно из двух состояний.

Промежуточные итоги: исполнитель выполняет задачу, затем вызывает `resolve` или `reject`, чтобы изменить состояние соответствующего `Promise`.

Промис - и успешный, и отклоненный будем называть "завершенными", в отличие от изначального промиса "в ожидании"

> **Может быть что-то одно: либо результат, либо ошибка**
> Исполнитель должен вызвать что-то одно: `resolve` или `reject`. Состояние промиса может быть изменено только один раз.
> ```
> let promise = new Promise(function(resolve, reject) {
>   resolve("done");
>    
>   reject(new Error("…")); // игнорируется
>   setTimeout(() => resolve("…")); // игнорируется
> });
> ```

> **Вызывайте `reject` с объектом `Error`**

>  **Свойства `state` и `result` – внутренние**
> Свойства `state` и `result` - это внутренние свойства объекта `Promise` и мы не имеем к ним прямого доступа.

## Потребители: then, catch, finally

Объект `Promise` служить связующим звеном между исполнителем и функциями-потребителями, которые получают либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы с помощью методов `.then`, `.catch` и `.finally`.

### then

```
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
```

Первый аргумент метода - функция, которая выполняется, когда промис переходит в состояние "выполнено успешно", и получает результат.

Второй аргумент - функция, которая выполняется, когда промис переходит в состояние "выполнено с ошибкой", и получает ошибку.

Если мы заинтересованы только в результате успешного выполнения задачи, то второй аргумент передавать необязательно.

### catch

Если мы хотим только обработать ошибку, то можно использовать `null` в качестве первого аргумента, или можно воспользоваться методом `catch(errorHandlingFunction)`, который сделает тоже самое:

```
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это то же самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
```

Вызов `.catch(f)` – это сокращённый, «укороченный» вариант `.then(null, f)`.

### finally

Выполнится в любом случае, когда промис завершится.

Хорошо подходит для очистки индикатора загрузки.

Обработчик в `finally` не имеет аргументов. И `finally` не знает как был завершен промис.

`finally` пропускает результат или ошибку дальше к последующим обработчикам (выполняется последним)