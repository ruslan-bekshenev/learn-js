# Циклы while и for

## Цикл "while"

```
  while (condition) {
    // код, тело цикла
  }
```

Код из тела цикла выполняется до тех пор пока **condition** истинно.

```
  let i = 0;
  while (i < 3) { // выводит 0, затем 1, затем 2
    alert( i );
    i++;
  }
```

Одно выполнение тела цикла по-научному называется **итерация**.

Если строка **i++** отсутствовала бы в теле цикла, то цикл бы повторялся вечно. Браузер не позволит такому случить, он предоставит пользователю возможность остановить "подвисший" скрипт, а на стороне сервера придется "убить" процесс.

Любое выражение или переменная может быть условием цикла, а не только сравнение: условие **while** вычисляется и преобразуется в логическое значение.

```
  let i = 3;
  while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
    alert( i );
    i--;
  }
```

**Фигурные скобки не требуется для тела цикла из одной строки**

## Цикл «do…while»

Проверку условия можно разместить под телом цикла, используя специальный синтаксис **do..while**:

```
  do {
    // тело цикла
  } while (condition);
```

Цикл сначала выполнит тело, а затем проверит условие, и пока его значение равно **true**, он будет выполняться снова и снова.

Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз.

## Цикл «for»

Более сложный, но при этом самый распространенный цикл - цикл **for**

```
  for (начало; условие; шаг) {
    // ... тело цикла ...
  }

  for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
    console.log(i);
  }
```

### Конструкция for

- начало **i = 0** выполняется один раз при входе в цикл
- условие **i < 3** проверяется перед каждой итерацией цикла. Если оно вычисляется в false, цикл остановится
- шаг **i++** выполняется после тела цикла на каждой итерации перед проверкой условия
- тело выполняется снова и снова, пока условие вычисляется в **true**

В целом, алгоритм работы цикла выглядит следующим образом:

```
  Выполнить *начало*
  → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
  → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
  → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
  → ...
```

### Встроенное объявление переменной

В примере переменная счетчика **i** была объявлена прям в цикле. Это так называемое "встроенное" объявление переменной. Такие переменные существуют только внутри цикла

## Пропуск частей «for»

Любая часть **for** может быть пропущена.

Для примера, мы можем пропустить **начало** если на ничего не нужно делать перед стартом цикла.

```
  let i = 0; // мы уже имеем объявленную i с присвоенным значением

  for (; i < 3; i++) { // нет необходимости в "начале"
    alert( i ); // 0, 1, 2
  }
```

Можно убрать и **шаг**:

```
  let i = 0;

  for (; i < 3;) {
    alert( i++ );
  }
```

Такой цикл сделает цикл аналогичным **while (i < 3)**.

А можно и вообще убрать всё, получив бесконечный цикл:

```
  for (;;) {
    // будет выполняться вечно
  }
```

## Прерывание цикла: «break»

Обычно цикл прерывается при вычислении условия в false.

Но можно прервать цикл в любой момент с помощью специальной директивы **break**, которая полностью прекращает выполнение цикла 

## Переход к следующей итерации: continue

Похоже на **break**, только не прерывает цикл, а переходит к следующей итерации, игнорируя код тела цикла, который описан ниже после **continue** 

### Нельзя использовать break/continue справа от оператора „?“

Так как синтаксические конструкции не являются выражениями и не могу быть использованы тернарным оператором "?". В частности, использование таких директив, как **break/continue**, вызовет ошибку.

```
  (i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
```

## Метки для break/continue

Это идентификаторы с двоеточием перед циклом. Необходимы для того, чтобы прервать или пропустить цикл по его идентификатору.

```
  labelName: for(...) { 
    ... 
  }

```
Вызов **break <labelName>** в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.

```
  outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {
      let input = prompt(`Значение на координатах (${i},${j})`, '');
      // если пустая строка или Отмена, то выйти из обоих циклов
      if (!input) break outer; // (*)
      // сделать что-нибудь со значениями...
    }
  }

  alert('Готово!');
```
В примере выше это означает, что вызовом **break outer** будет разорван внешний цикл до метки с именем **outer**, и управление перейдёт со строки, помеченной **(*)**, к **alert('Готово!')**.