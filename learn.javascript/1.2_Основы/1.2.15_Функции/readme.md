# Функции

Зачастую надо повторять одно и то же действие во многих частях программы.

Чтобы не повторять один и тот же код во многих местах, придуманы функции. Фунциии являются основными "строительными блоками" программы.

## Объявление функции

Для создания функции мы можем использовать объявление функции

```
  function showMessage() {
    alert('Всем привет!');
  }
```

При объявлении, в начале идет ключевое слово **function**, далее идет имя функции, затем в круглых скобках идет перечисление параметров, а после в фигурных скобках описывается тело функции.

Также список параметров может быть пустым, как в примере выше.

Функция может быть вызвана по ее имени: **showMessage()**

Функция позволяет не дублировать код. Если нужно изменить сообщение, то достаточно его изменить лишь в одном месте: в функции, которая его выводит.

## Локальные переменные

Переменные объявленные внутри функции, видны только внутри функции.

## Внешние переменные

У функции есть доступ к внешним переменным. Функция обладает полным доступом к внешним переменным и может изменять их значение.

```
  let userName = 'Вася';

  function showMessage() {
    userName = "Петя"; // (1) изменяем значение внешней переменной

    let message = 'Привет, ' + userName;
    alert(message);
  }

  alert( userName ); // Вася перед вызовом функции

  showMessage();

  alert( userName );
```

Внешняя переменная используется, только если внутри функции нет такой локальной.

Если одноименная переменная объявляется внутри функции, тогда она перекрывает внешнюю.

### Глобальные переменные

Переменные, объявленные снаружи всех функций, называют глобальными.

Глобальные переменные видимы для любой функции (если только их не перекрывают одноименные локальные переменные).

Желательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных. Хотя они иногда полезны для хранения важнейших «общепроектовых» данных.

## Параметры

В функции можно передавать любую информацию, используя параметры (также называемые аргументами функции)

Функци копирует переданные параметры в локальные переменные и затем использует их в теле функции.

Также параметры можно изменять в теле функции и эти изменения не будут видны снаружи. Функция всегда получает только копию значения.

## Параметры по умолчанию

Если параметр не указан, то его значением становится **undefined**

Чтобы задать параметру значение по умолчанию, мы должны указать его после **=**:

```
  function showMessage(from, text = "текст не добавлен") {
    alert( from + ": " + text );
  }

  showMessage("Аня"); // Аня: текст не добавлен
```

Теперь если параметр **text** не указан, его значением будет **текст не добавлен**.

### Вычисление параметров по умолчанию

В Javascript параметры по умолчанию вычисляются каждый раз, когда функция вызывается без соответствующего параметра.

### Использование параметров по умолчанию в ранних версиях JavaScript

Ранние версии JS не поддерживали параметры по умолчанию. Поэтому существуют альтернативные способы, которые могу встречаться в старых скриптах.

Например, явная проверка на **undefined**:

```
  function showMessage(from, text) {
    if (text === undefined) {
      text = 'текст не добавлен';
    }

    alert( from + ": " + text );
  }

  // или с помощью оператора ||

  function showMessage(from, text) {
    // Если значение text ложно, тогда присвоить параметру text значение по умолчанию
    text = text || 'текст не добавлен';
    ...
  }
```

## Возврат значения

Функция может вернуть результат, который будет передан в вызвавший ее код.

Пример:

```
  function sum(a, b) {
    return a + b;
  }

  let result = sum(1, 2);
  alert( result ); // 3
```

Директива **return** может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается и значение возвращается в вызваший ее код.

Вызовов **return** может быть несколько:

```
  function checkAge(age) {
    if (age > 18) {
      return true;
    } else {
      return confirm('А родители разрешили?');
    }
  }

  let age = prompt('Сколько вам лет?', 18);

  if ( checkAge(age) ) {
    alert( 'Доступ получен' );
  } else {
    alert( 'Доступ закрыт' );
  }
```

Также можно использоваться **return** без значения. Это приведет к немедленному выходу из функции.

### Результат функции с пустым return или без него – undefined.

**return === return undefined**

### Никогда не добавляйте перевод строки между return и его значением

Код не выполнится, потому что интерпретатор подставить точку с запятой после return.

Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке, что и **return**. Либо можно поставить там открывающую скобку.

## Выбор имени функции

Функция - это действие. Поэтому имя функции обычно является глаголом. Оно должно быть простым, точно описывать действие функции, чтобы программист, который будет читать код, получил верное представление о том, что делает функция.

Как правило, используют глагольные префиксы, обозначающие общий характер действия, после который следует уточнение. Обычно в командах разработчиков действуют соглашения, касающиеся значений  этих префиксов.

Например, функции, начинающиеся с "show" обычно что-то показывают.

Функции, начинающиеся с…

- "get…" – возвращают значение,
- "calc…" – что-то вычисляют,
- "create…" – что-то создают,
- "check…" – что-то проверяют и возвращают логическое значение, и т.д.

Благодаря префиксам, при первом взгляде на имя функции становится понятным что делает ее код, и какое значение она может возвращать.

### Одна функция – одно действие

Функция должна делать то, что явно подразумевается ее название. И это должно быть одним действием.

Два независимых действия обычно подразумевает две функции, даже если предполагается, что они будут вызываться вместе.

### Сверхкороткие имена функций

Имена функций, которые используются очень часто, иногда делают сверхкороткими.

Например **Lodash** основная функция представлена именем "_".

## Функции == Комментарии

Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию на несколько меньших.

Небольшие функции не только облегчают тестирование и отладку - само существование таких функций выполняет роль хороших комментариев. 