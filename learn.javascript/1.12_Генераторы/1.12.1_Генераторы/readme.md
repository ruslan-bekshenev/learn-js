# Генераторы

Генераторы могут порождать (yield) множество значений одно за другим, по мере необходимости. Генераторы отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных.

## Функция-генератор

Для объявления генератора используется синтаксическая конструкция `function*`, которая называется «функция-генератор».

Когда функция вызвана, она не выполняет свой код, вместо этого она возвращает специальный объект, так называемый "генератор".

Основным методом генератора является `next()`. При вызове он запускает выполнение кода до ближайшей инструкции `yield <значение>`. По достижению `yield` выполнение функции приостанавливается, а соответствующее значение возвращается во внешний код:

Результатом метода `next()` всегда является объект с двумя свойствами:

- `valye` значение из `yield`.
- `done: true/false`, если значение выполнение функции завершено или не завершено

## Перебор генераторов

Так как это перебираемый объект, по нему можно пробежаться через `for..of`. Последнее значение будет игнорироваться, если возврат значение идет через `return`.

## Композиция генераторов

Композиция генераторов – это особенная возможность генераторов, которая позволяет прозрачно «встраивать» генераторы друг в друга.

`yield*` позволяет "вкладывать" генераторы один в другой. Директива делегирует выполнение другому генератору.

Композиция генераторов – естественный способ вставлять вывод одного генератора в поток другого. Она не использует дополнительную память для хранения промежуточных результатов.

## yield – дорога в обе стороны

`yield` не только возвращает результат наружу, но и может передавать значение извне в генератор.

## Итого

Генераторы создаются при помощи функций-генераторов f`unction* f(…) {…}`.
Внутри генераторов и только внутри них существует оператор `yield`.
Внешний код и генератор обмениваются промежуточными результатами посредством вызовов `next/yield`.
В современном JavaScript генераторы используются редко. Но иногда они оказываются полезными, потому что способность функции обмениваться данными с вызывающим кодом во время выполнения совершенно уникальна. И, конечно, для создания перебираемых объектов.

Также, в следующей главе мы будем изучать асинхронные генераторы, которые используются, чтобы читать потоки асинхронно сгенерированных данных (например, постранично загружаемые из сети) в цикле `for await ... of`.


