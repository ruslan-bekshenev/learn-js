# Декораторы и переадресация вызова, call/apply

В этой главе мы рассмотрим как перенаправлять вызовы между функциями и как их декорировать

## Прозрачное кеширование

Если есть функция `func(x)`, которая выполняет ресурсоемкие задачи, но возвращающая стабильный результат (один и тот же результат) и сама функция вызывается часто, то вероятно следует запоминать возвращаемые результаты (кэшировать), чтобы сэкономить время на повторных вычислениях.

Для этого можно использовать функцию-обертку(декоратор), с помощью которой мы будем кэшировать результат функции.

Сама по себе функция не будет изменяться, но будет изменяться ее поведение благодаря декоратору.

Данную функцию-обертку можно будет использовать не только для конкретной функции, но и для других.

Обернутая функция будет по-прежнему выполнять тоже самое, обертка будет лишь добавлять к ее поведению аспект кэширования.

Небольшой итог:

- Декоратор можно использовать повторно, применять ее к другим функциям
- Логика кэширования является отдельной, она не увеличивает сложность обернутой функции
- При необходимости можно объединить несколько декораторов.

## Применение «func.call» для передачи контекста.

Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов.

Например, в приведённом ниже коде `worker.slow()` перестаёт работать после применения декоратора:

```
// сделаем worker.slow кеширующим
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    // здесь может быть страшно тяжёлая задача для процессора
    alert("Called with " + x);
    return x * this.someMethod(); // (*)
  }
};

// тот же код, что и выше
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x); // (**)
    cache.set(x, result);
    return result;
  };
}

alert( worker.slow(1) ); // оригинальный метод работает

worker.slow = cachingDecorator(worker.slow); // теперь сделаем его кеширующим

alert( worker.slow(2) ); // Ой! Ошибка: не удаётся прочитать свойство 'someMethod' из 'undefined'
```

Ошибка возникает из-за того, что мы пытаемся вызвать `this.someMethod` в строке (*). Причина в том, что теряется контекст, так как декоратор вызывает оригинальную функцию `func(x)`.

Для этого существует специальный метод `func.call(context, ...args)`, который позволяет вызывать функцию, явно устанавливая `this`.

Он запускает функцию передавая контекст первым аргументом.

В контексте нашего примера, применение функции `func.call` будет выглядеть следующим образом:

```
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    alert("Called with " + x);
    return x * this.someMethod(); // (*)
  }
};

function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func.call(this, x); // теперь 'this' передаётся правильно
    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow); // теперь сделаем её кеширующей

alert( worker.slow(2) ); // работает
alert( worker.slow(2) ); // работает, не вызывая первоначальную функцию (кешируется)
```

Теперь все работает, так как в строке `let result = ...`, мы передаем нашей функции первым аргументом в качестве контекста объект `worker`.

## Переходим к нескольким аргументам с «func.apply»

Схожая с функцией `call`, только вместо списка аргументов `...args`, принимает псевдомассив `args`.

Также `apply` будет быстрее, потому что большинство движков JS внутренне оптимизируют его лучше.

Передача всех аргументов вместе с контекстом другой функции называется «перенаправлением вызова» (call forwarding).

## Заимствование метода

Так как `arguments` является псевдомассивом, методы массивов для него не работают.

Чтобы это исправить, можно использовать один трюк:

```
function hash() {
  alert( [].join.call(arguments) ); // 1,2
}

hash(1, 2);
```

Этот трюк называется _заимствование метода_.

По сути мы берем метод `join` из обычного массива и через `call` выполняем метод `join` в контексте `arguments`.

## Итого

Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.