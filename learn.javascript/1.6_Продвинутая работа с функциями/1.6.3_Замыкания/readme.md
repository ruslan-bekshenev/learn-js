# Замыкание

## Лексическое Окружение

Это внутренний объект внутри выполняемой функции, блока кода или скрипта.

Объект лексического окружения состоит из двух частей:
- Environment Record - объект в котором хранятся локальные переменные в виде свойств.
- Ссылка на внешние лексические окружения.

**"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».**

Переменная - это свойство специального внутреннего объекта связанного с текущим выполняющимся блоком/функцией/скриптом.

Работа с переменными - это на самом деле работа со свойствами этого объекта.

## Function Declaration

Инициализируются когда создается лексическое окружение.

Дла верхнеуровневых - когда скрипт начинается выполнение (в самом вверху скрипта).

## Внутреннее и внешнее лексическое окружение

При запуске функции для неё автоматически создаётся новое лексическое окружение, для хранения локальных переменных и параметров вызова.

В процессе вызова функции есть два лексических окружения: внутреннее и внешнее.

Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.

Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.

Функция получает текущее значение внешних переменных, то есть, их последнее значение.

Лексическое окружение - специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую. Сам движок JS может оптимизировать его, уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие внутренние уловки, но видимое поведение объекта должно оставаться таким, как было описано

## Вложенные функции

Функция называется вложенной, когда она создается внутри другой функции.

Вложенная функция может быть возвращена: либо в качестве свойства нового объекта, либо сама по себе. И затем может быть использована в любом месте.

Если внутренняя функция начинает выполняться и в ней используется переменная, то начинается поиск:

1. В начале поиск идет по локальным переменным (переменным, объявленные внутри этой же функции)
2. Переменный внешней функции
3. И тд, пока не будут достигнуты глобальные переменные

## Окружение в деталях

Рассмотрим на примере. Есть функция:

```
function makeCounter() {
  let count = 0;
  return function() {
    return count++;
  };
}

let counter1 = makeCounter();
let counter2 = makeCounter();

alert( counter1() ); // 0
alert( counter1() ); // 1

alert( counter2() ); // 0 (независимо)
```

1. Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение.

Все функции "при рождении" получают скрытое свойство `[[Environment]]`, которое ссылается на лексическое окружение места, где они были созданы.

`[[Environment]]` - скрытое свойство функции, которое содержит эту ссылку.

2. Код продолжает выполняться, объявляется новая глобальная переменная `counter`, которой присваивается результат вызова `makeCounter`.
 
    В момент вызова `makeCounter` создается лексическое окружение, для хранения его переменных и аргументов

    Как и все лексические окружения, функция содержит две вещи:

  - Environment Record с локальными переменными.
  - Ссылка на внешние окружения, которая устанавливается в значение `[[Environment]]` функции

3. В процессе выполнения `makeCounter()` создается небольшая вложенная функция.

    Вне зависимости от того, каким способом объявлена функция, она получается свойство `[[Environment]]`, которое ссылается на лексическое окружение, в котором они были созданы.

4. Выполнение продолжается, вызов `makeCounter()` завершается, и результат присваивается глобальной переменной. 

5. При вызове `counter()` для этого вызова создается новое лексическое окружение. 

6. Вызов `counter()` не только возвращает значение `count`, но также увеличивает его.

7. Следующие вызовы `counter()` сделают то же самое.

Замыкание - функция, которая запоминает свои внешние переменные и может получить к ним доступ. В JS, все функции изначально являются замыканиями (исключение синтаксис "new Function")

То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]` и все они могут получить доступ к внешним переменным.

## Блоки кода и циклы, IIFE

