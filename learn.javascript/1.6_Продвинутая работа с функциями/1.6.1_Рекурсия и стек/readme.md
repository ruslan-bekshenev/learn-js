# Рекурсия и стек

Рекурсия - это функция, которая вызывается саму себя.

Рекурсивное решение обычно короче, чем итеративное.

Общее количество вложенных вызовов называют _глубиной рекурсии_.

Максимальная глубина рекурсии ограничена движком JS.

У рекурсии обязательно должна быть точка выхода

Точно можно рассчитывать на 10000 выложенных вызовов. Неокторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов - за пределами возможностей.

## Контекст выполнения, стек

Информация о процессе выполнения запущенной функции хранится в ее контексте выполнения.

Контекст выполнения - специальная внутренняя структура данных, которая содержит информацию о вызове функции.

Она включается в себя конкретное место в коде, локальные переменные функции, `this` и тд.

Один вызов функции имеет ровно один контекст выполнения связанный с ним.

Когда функция производит вложенный вызов, происходит следующее:

1. Выполнение текущей функции приостанавливается.
2. Контекст выполнения, связанный с ней, запоминается в специальной структуре данных - стеке контекстов выполнения.
3. Выполняются вложенные вызовы, для каждого из которых создается свой контекст выполнения.
4. После их завершения старый контекст достается из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.

Контекст выполнения удаляется из памяти тогда, когда функция заканчивается.

**Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.**

## Рекурсивные структуры

Рекурсивная структура данных - структура, которая повторяет саму себя в своих частях.

### Связанный список

Базовая динамическая структура данных в информатике, состоящая из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки на следующий или предыдущий узел списка.

Элемент связаного списка определяется рекурсивно как объект.

- `value`
- `next` - свойство,ссылающееся на следующий элемент связного списка или `null`, если это последний элемент.

`
let list = {
    value: 1,
    next: {
        value: 2,
        next: {
            value: 3,
            next: {
                value: 4,
                next: null
            }
        }
    }
};
`

Список можно разделить на несколько частей и в последствии объединить обратно:

`
    let secondList = list.next.next;
    list.next.next = null;
`

Для объединения 

`
    list.next.next = secondList;
`

Для добавления нужно обновить первый элемент списка:

`
    let list = { value: 1 };
    list.next = { value: 2 };
    list.next.next = { value: 3 };
    list.next.next.next = { value: 4 };
    
    // добавление нового элемента в список
    list = { value: "new item", next: list };
`

Чтобы удалить элемент из середины списка, нужно изменить значение `next` предыдущего элемента:

`
    list.next = list.next.next;
`

Списки могут быть улучшены:

- Добавить свойство `prev` - ссылка на предыдущий элемент
- Добавить переменную `tail`, которая будет ссылаться на последний элемент списка
