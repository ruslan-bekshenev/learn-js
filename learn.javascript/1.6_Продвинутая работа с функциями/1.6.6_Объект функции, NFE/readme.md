# Объект функции, NFE

В JS функции - объекты

Функцию можно использовать как обычный объект: добавлять/удалять свойства, передавать их по ссылке и т.д.

## Свойство «name»

Хранит в себе имя функции. Логика назначения `name` весьма умная. Она присваивает корректное имя даже если функция создается без имени.

В спецификации это называется "контекстное имя": если функция не имеет name, то JS пытается определить его из контекста.

Если имя функции определить невозможно, то name хранит пустое значение.

## Свойство «length»

Хранит количество параметров в ее объявлении.

Остаточные параметры не считаются

Своство `length` иногда используется для интроспекций в функциях, которые работают с другими функциями.

Например, в коде ниже функция `ask` принимает в качестве параметров  вопрос `question` и произвольно количество функций-обработчиков ответа `handler`.

Когда пользователь отвечает на вопрос, функция вызывает обработчики. Мы можем передавать два типа обработчиков:

- Функцию без аргументов, которая будет вызываться только в случае положительного ответа
- Функцию с аргументами, которая будет вызываться в обоих случаях и возвращать ответ.

Чтобы вызвать обработчик `handler` будем проверять свойство `handler.length`.

Идея состоит в том, чтобы иметь простой синтаксис обработчика без аргументов для положительных, но также и возможность передавать универсальные обработчики:

```
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for(let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }

}

// для положительных ответов вызываются оба типа обработчиков
// для отрицательных - только второго типа
ask("Вопрос?", () => alert('Вы ответили да'), result => alert(result));
```

Это частный случа так называемого Ad-Hoc-полиморфизма - обработка аргументов в зависимости от их типа или, как в нашем случае - от значения `length`.

## Пользовательские свойства

Свойства функции не объявляют локальную переменную внутри нее.

Можно использовать функцию как объект, хранить в ней свойства, но они никак не влияют на ее выполнение.

Свойства функций можно использовать вместо замыканий.

```
function makeCounter() {
  // вместо
  // let count = 0

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1
```

Свойство `count` теперь хранится прямо в функции, а не в её внешнем лексическом окружении.

Основное отличие в том, что если `count` живет во внешней переменной, то оно не доступно для внешнего кода. Изменить его могут только вложенные функции. 

А если присвоено как свойство функции, то его можно получить.

## Named Function Expression

Named Function Expression или NFE – это термин для Function Expression, у которого есть имя.

Можно задавать функции имя после ключевого слова `function` в Function Expression.

Имя не превращает объявление в Function Declaration, потому что оно все еще является частью выражения присваивания.

Особенности имени:

1. Оно позволяет функции ссылаться на себя же
2. Оно не доступно за пределами функции.

```
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // использует func, чтобы снова вызвать себя же
  }
};

sayHi(); // Hello, Guest

// А вот так - не cработает:
func(); // Ошибка, func не определена (недоступна вне функции)
```

Такой синтаксис удобнее, так как `sayHi` может быть изменено. Функция может быть присвоена другой переменной и тогда будет ошибка.

Так происходит, потмоу что функция берет `sayHi` из внешнего лексического окружения. Так как локальная переменная `sayHi` отсутствует, используется внешняя.

**Это не работает с Function Declaration**

