# Привязка контекста к функции

При передаче методов объекта в качестве коллбэков, возникает известная проблема - потеря `this`

## Потеря «this»

Как только метод передается отдельно от объекта - `this` теряется.

```
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Привет, undefined!
```

Метод `setTimeout` в браузере устанавливает `this=window` для вызова функции. В Node.js `this` становится объектов таймера.

Есть 2 способа исправить это:

- Сделать функцию-обертку
- Привязать контекст с помощью `bind`

## Функция-обертка

Самый простой способ - обернуть в анонимную функцию, создав замыкание:

```
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

setTimeout(function() {
  user.sayHi(); // Привет, Вася!
}, 1000);
```

Но у этого метода есть одна уязвимость: если в переменной перезаписать значение до срабатывания `setTimeout`, то вызов будет совсем не тот.

```
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

setTimeout(() => user.sayHi(), 1000);

// ...в течение 1 секунды
user = { sayHi() { alert("Другой пользователь в 'setTimeout'!"); } };

// Другой пользователь в 'setTimeout'!
```

Второй способ избавляет от этой проблемы

## Привязать контекст с помощью bind

Метод позволяет зафиксировать `this`

Результатом вызова `func.bind(context)` является особый объект, который вызывается как функция и прозрачно передает вызов в `func`, устанавливая context.

## Частичное применение

Это создание новой функции с фиксацией аргументов.

Используется для того, чтобы создать независимую функцию с понятным названием. Можем использовать ее и не передавать каждый раз аргументы, так как они зафиксированы.

```
function mul(a, b) {
  return a * b;
}

let triple = mul.bind(null, 3);

alert( triple(3) ); // = mul(3, 3) = 9
alert( triple(4) ); // = mul(3, 4) = 12
alert( triple(5) ); // = mul(3, 5) = 15
```

В других случаях частичное применение полезно, когда у нас есть очень общая функция и для удобства мы хотим создать её более специализированный вариант.

## Частичное применение без контекста

Фиксация аргументов без привязки контекста.

`bind` такого не позволяет, поэтому можно создать вспомогательную функцию.

```
function partial(func, ...argsBound) {
  return function(...args) { // (*)
    return func.call(this, ...argsBound, ...args);
  }
}

// использование:
let user = {
  firstName: "John",
  say(time, phrase) {
    alert(`[${time}] ${this.firstName}: ${phrase}!`);
  }
};

// добавляем частично применённый метод с фиксированным временем
user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());

user.sayNow("Hello");
// Что-то вроде этого:
// [10:00] John: Hello!
```

Результатом вызова `partial(func[, arg1, arg2...])` будет обёртка (*), которая вызывает `func` с:

- Тем же `this`, который она получает (для вызова `user.sayNow` – это будет `user`)
- Затем передаёт ей `...argsBound` – аргументы из вызова `partial("10:00")`
- Затем передаёт ей `...args` – аргументы, полученные обёрткой (`Hello`)

## Итого

Метод bind возвращает «привязанный вариант» функции func, фиксируя контекст `this` и первые аргументы `arg1`, `arg2…`, если они заданы.

Обычно bind применяется для фиксации `this` в методе объекта, чтобы передать его в качестве колбэка. Например, для `setTimeout`.

Когда мы привязываем аргументы, такая функция называется «частично применённой» или «частичной».

Частичное применение удобно, когда мы не хотим повторять один и тот же аргумент много раз.