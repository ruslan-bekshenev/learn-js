# Планирование: setTimeout и setInterval

Функцию можно вызвать не в данный момент времени, а через заданный интервал. Это называется "планирование вызова".

Для этого существуют 2 метода:

- `setTimeout` позволяет вызвать функцию один раз через определенный интервал времени.
- `setInterval` позволяет вызвать функцию регулярно, повторяя вызов через определенный интервал времени.

Эти методы не являются частью спецификации JS. Но большинство сред выполнения JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам.

## setTimeout

```
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```

- `func|code`
    
Функция или строка для выполнения. Передавать строку кода не рекомендуется

- `delay`

Задержка перед запуском в миллисекундах, по умолчанию значение - 0ю

- `arg1`, `arg2` ...

Аргументы передаваемые в функцию (не поддерживается в IE9)

```
function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}

setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон
```

Если первый аргументом передать строку, то JS создаст из нее функцию. Будет работать также, но крайне не рекомендуется использовать сроки.

`setTimeout` первым аргументом ожидает ссылку на функцию, а не саму функцию (ошибка начинающих разработчиков)

### Отмена через clearTimeout

Вызов `setTimeout` возвращается id таймера, который можно использовать для отмены дальнейшего выполнения.

```
let timerId = setTimeout(...);
clearTimeout(timerId);
```

## setInterval

Метод имеет такой же синтаксис как и `setTimeout`.

Отличие заключается в том, что функция запускается регулярно в указанный интервал времени, а не один раз.

Чтобы остановить дальнейшее выполнение функции, необходимо вызвать `clearInterval(timerId)`

## Вложенный setTimeout

Есть два способа запускать что-то регулярно.

Один из них `setInterval`. Другим является вложенный `setTimeout`:

```
/** вместо:
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);
```

`setTimeout` выше планирует следующий вызов прямо после окончания текущего (*).

Вложенный `setTimeout` - более гибкий метод, чем `setInterval`. С его помощью последующий вызов может быть задан по-разному в зависимости от результатов предыдущего.

Вложенный `setTimeout` позволяет задать задержку между выполнениями более точно, чем `setInterval`.

Реальная задержка между вызовами функции с помощью `setInterval` может быть меньше чем указано в коде, так как время затраченное на выполнение этой функции, используется часть заданного интервала времени.

Вполне вероятно, что время выполнение функции займет дольше чем мы ожидали.

Вложенный `setTimeout` гарантирует фиксированную задержку, потому что вызов планируется в конце предыдущего.

### Сборка мусора и колбэк setTimeout/setInterval

Когда функция передается в `setTimeout/setInterval`, на нее создается внутренняя ссылка и сохраняется в планировщике. Это предотвращает попадание функции в сборщик мусора, даже если на нее нет других ссылок.

Для `setInterval` функция остается в памяти до тех пор, пока не будет вызван `clearInterval`.

Есть и побочный эффект. Функция ссылается на внешнее лексическое окружение, поэтому пока она существует, внешние переменные существуют тоже.

## setTimeout с нулевой задержкой

Особый вариант использования: `setTimeout(func, 0)` или `setTimeout(func)`

Это планирует вызов `func` настолько быстро, насколько это возможно. Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.

Так вызов функции будет запланирован сразу после выполнения текущего кода.


### Минимальная задержка вложенных таймеров в браузере

В браузере есть ограничения на то, как часто внутренние счетчики могут выполняться. В стандарте HTML5 говорится, что после пяти вложенных таймеров, минимальная задержка должна составлять не менее 4х миллисекунд.

Этого ограничения нет в серверном JS.

## Итого

Обратим внимание, что все методы планирования не гарантируют точную задержку.

Например, таймер в браузере может замедляться по многим причинам:

- Перегружен процессор.
- Вкладка браузера в фоновом режиме.
- Работа ноутбука от аккумулятора.

Всё это может увеличивать минимальный интервал срабатывания таймера (и минимальную задержку) до 300 или даже 1000 мс в зависимости от браузера и настроек производительности ОС.