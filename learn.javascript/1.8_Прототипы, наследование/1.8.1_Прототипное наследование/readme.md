# Прототипное наследование

## `[[Prototype]]`

Прототип - это скрытое свойство, которое либо равно `null`, либо ссылается на другой объект.

Прототипное наследование - механизм, который достает свойство из прототипа, если это свойство отсутствует в самом объекте.

`[[Prototype]]` является внутренним и скрытым.

С помощью свойство `__proto__` можно задать прототип для объекта.

Свойство `__proto__` — исторически обусловленный геттер/сеттер для `[[Prototype]]`

В современном JavaScript `__proto__` заменяют такие функции, как `Object.getPrototypeOf/Object.setPrototypeOf`, которые получают и устанавливают прототип.

`__proto__` поддерживается всеми средами.

```
    let animal = {
      eats: true
    };
    let rabbit = {
      jumps: true
    };
    
    rabbit.__proto__ = animal; // (*)
    
    // теперь мы можем найти оба свойства в rabbit:
    alert( rabbit.eats ); // true (**)
    alert( rabbit.jumps ); // true
```

### Ограничения:

1) Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить `__proto__` по кругу.
2) Значение `__proto__` может быть объектом или null. Другие типы игнорируются.

## Операция записи не использует прототип

Прототип используется только для чтения свойств.

Операции записи/удаления работают напрямую с объектом.

Свойства-аксессоры – исключение, так как запись в него обрабатывается функцией-сеттером. То есть, это, фактически, вызов функции.

```
    let user = {
      name: "John",
      surname: "Smith",
    
      set fullName(value) {
        [this.name, this.surname] = value.split(" ");
      },
    
      get fullName() {
        return `${this.name} ${this.surname}`;
      }
    };
    
    let admin = {
      __proto__: user,
      isAdmin: true
    };
    
    alert(admin.fullName); // John Smith (*)
    
    // срабатывает сеттер!
    admin.fullName = "Alice Cooper"; // (**)
    alert(admin.name); // Alice
    alert(admin.surname); // Cooper
```

Здесь в строке `(*)` свойство `admin.fullName` имеет геттер в прототипе user, поэтому вызывается он. В строке `(**)` свойство также имеет сеттер в прототипе, который и будет вызван.

## Значение «this»

Прототипы никак не влияют на `this`.

Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.

Наследующие объекты могут вызывать методы прототипа, но изменять они будут свое состояние, а не состояние объекта-родителя.

## Цикл for…in

Цикл `for..in` проходит не только по собственным, но и по унаследованным свойствам объекта.

Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода `obj.hasOwnProperty(key)`: он возвращает `true`, если у `obj` есть собственное, не унаследованное, свойство с именем `key`.

```
    let animal = {
      eats: true
    };
    
    let rabbit = {
      jumps: true,
      __proto__: animal
    };
    
    for(let prop in rabbit) {
      let isOwn = rabbit.hasOwnProperty(prop);
    
      if (isOwn) {
        alert(`Our: ${prop}`); // Our: jumps
      } else {
        alert(`Inherited: ${prop}`); // Inherited: eats
      }
    }
```