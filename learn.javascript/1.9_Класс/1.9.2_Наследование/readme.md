# Наследование классов

Чтобы наследовать класс от другого, мы должны использовать ключевое слово `extends` и указать название родительского класса перед `{...}`. После чего дочернему классу будут доступны методы родительского класса.

Ключевое слово `extends` работает, используя прототипы. Оно устанавливает `ChildClass.prototype.[[Prototype]]` в `ParentClass.prototype`. Если метод не будет найден в дочернем классе, то JavaScript берет его из родительского.

## Переопределение методов

Если мы определим свой метод в дочернем классе, то он будет использоваться взамен родительского.

Если мы не хотим полностью заменить родительский метод, а скорее хоти сделать новый на его основе, изменяя или расширяя его функциональность. Мы делаем что-то в нашем методе и вызываем родительский метод до/после или в процессе.

У классов есть ключевое слово `super` для таких случаев.

- `super.method(...)` вызывает родительский метод.
- `super(...)` вызывает родительский конструктор (работает только внутри нашего конструктора).

### У стрелочных функций нет super

При обращении к `super` стрелочной функции он берётся из внешней функции

## Переопределение конструктора

Согласно спецификации, если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой «пустой» конструктор.

В JavaScript существует различие между «функцией-конструктором наследующего класса» и всеми остальными. В наследующем классе соответствующая функция-конструктор помечена специальным внутренним свойством `[[ConstructorKind]]:"derived"`.

Разница в следующем:

- Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this .
- Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.

Поэтому, если мы создаём собственный конструктор, мы должны вызвать `super`, в противном случае объект для `this` не будет создан, и мы получим ошибку.

## Устройство super, `[[HomeObject]]`

Методы запоминают свой объект во внутреннем свойстве `[[HomeObject]]`. Благодаря этому работает super, он в его прототипе ищет родительские методы.

Поэтому копировать метод, использующий super, между разными объектами небезопасно.